
########	THE R ENVIRONMENT & BASICS OF USING R SOFTWARE	########

# CONSOLE, EDITOR (SCRIPT), GRAPHICS WINDOW

setwd("C://Users/Kubo/Documents/Work/Empirical Research Methodology/Applied statistics in R")
data.bar<-read.delim("ChickFlick.dat", header = TRUE)
library(ggplot2)
barchart<-ggplot(data.bar, aes(film, arousal, fill = film))
barchart + stat_summary(fun.y = mean, geom = "bar",
colour = "Black") + stat_summary(fun.data = mean_cl_normal, geom = "errorbar"
, width = 0.2) + facet_wrap(~gender) + theme(legend.position = "none")

# R AS A CALCULATOR - EASY COMMANDS (PLUS, MINUS, DIVIDE, MULTIPLICATION)
# COMMAND = ANYTHING WE WRITE INTO CONSOLE

4+3
4-3
4*3
4/3
4**3
4+((3**5)*2)

# R AS A CALCULATOR - MATEHMATICAL OPERATIONS (BASIC FUNCTIONS)
# FUNCTION = (FUNCTIONS CAN BE EASILY IDENTIFIED BY PARENTHESES THAT FOLLOW)
#	SET OF COMMANDS COMPILED TOGETHER

sqrt()
log()

# PARENTHESES CONTAIN ARGUMENTS FOR A FUNCTION

sqrt(36)
log(10)

# R AS A CALCULATOR - OBJECTS AND THEIR CREATION
# OBJECT = ANY CONTENT (number, text, table, list, and so on...)
#	THAT WE STORE FOR LATER USE

	#CREATING OBJECTS FROM COMMANDS

	#	<-
	#
	#	(however, you can also use "=" if you prefer)

x <- 5*6
x

	#CREATING OBJECT Y

y <- 4*12
y

	#WORKING WITH OBJECTS

x+y
x*y
x/y

	#OJECTS CAN SERVE AS ARGUMENTS FOR FUNCTIONS

sqrt(x)
log(y)

	#WARNING! R IS CASE SENSITIVE!
	
X
Y







#WORKING WITH DATA - LOADING EXISTING DATA

#INSTALLING AND CALLING LIBRARIES

# CORE R ONLY CONTAINS VERY BASIC FUNCTIONS (such as sqrt(), log(), and so on)
# MORE ADVANCED FUNCTIONS ARE STORED IN PACKAGES (LIBRARIES), THAT YOU
# NEED TO INSTALL AND CALL BEFORE USING

install.packages("foreign")

	#YOU ONLY NEED TO INSTALL EVERY PACKAGE ONCE, BUT YOU NEED TO CALL
	#A PACKAGE EVERY TIME YOU WANT TO USE IT

library(foreign)

	#NOW WE CAN USE FUNCTIONS CONTAINED IN PACKAGE FOREIGN
	#BE AWARE OF THE QUATATION MARKS - YOU NEED TO USE THEM
	#WHEN INSTALLING PACKAGES, BUT NOT WHEN CALLING PACKAGES

# SETTIGN A WORKING DIRECTORY (IT IS NOT NECESSARY, BUT QUITE PRACTICAL)
	#FUNCTION SET WORKING DIRECTORY - setwd()

setwd("C://Users/Kubo/Documents/Work/Empirical Research Methodology/Applied statistics in R")

# IF YOU ARE NOT SURE ABOUT THE EXACT PATH TO YOUR FOLDER, YOU CAN USE
	#FUNCTION choose.dir(), WHICH ALLOWS US TO MANUALLY SELECT A FOLDER,
	#WITHIN A setwd() FUNCTION

setwd(choose.dir())






# GETTING HELP - R SOFTWARE HAS A HUGE ONLINE SUPPORT AND VERY
#	DETAILED ONLINE DOCUMENTATION

# WE CAN ACCESS THE DOCUMENTATION THROUGH HELP FUNCTION: ?

?log

# WE USE ONE QUESTION MARK IF WE ARE LOOKING FOR A DOCUMENTATION OF
#	A SINGLE FUNCTION

??ggplot2

# WE USE TWO QUESTION MARKS IF WE ARE LOOKING FOR A DOCUMENTATION OF A WHOLE
#	PACKAGE, OR IF WE DONT KNOW THE EXACT NAME OF A FUNCTION, WHICH WE
#	ARE LOOKING FOR









#LOADING THE EXISTING DATASET - THE EXACT PROCEDURE DEPENDS ON THE FORMAT
#	IN WHICH THE DATA ARE STORED

#	UP UNTIL NOW WE WORKED WITH BASIC FUNCTIONS THAT CONTAINED ONLY ONE
#	ARGUMENT, HOWEVER, THE FUNCTION FOR LOADING DATA HAS FOLLOWING
#	STRUCTURE:
#
#	read.delim(file, header = TRUE, na.strings = "NA")
#
#	file = file, which we want to load
#	header = are names of the variables included in the first row of the datafile?
#	na.strings = how are missing values labeled in the datafile?

read.delim(file = "RExam.dat", header = T, na.strings = "NA")

#IF WE DID NOT SET OUR WORKING DIRECTORY BEFOREHAND, WE WOULD HAVE TO INCLUDE A
#	WHOLE PATH TO THE DATAFILE

read.delim(file = "C://Users/Kubo/Documents/Work/Empirical Research Methodology/Applied statistics in R/RExam.dat", 
	header = T, na.strings = "NA")

# SIMILARLY, AS WITH MANUALLY CHOOSING A FOLDER WHEN SETTING A WORKING DIRECTORY,
#	WE CAN MANUALLY CHOOSE A FILE WHEN LOADING A DATASET WITH A FUNCTION
#	file.choose()

read.delim(file = file.choose(), header = T, na.strings = "NA")

# IF WE TRIED TO TELL R THAT THE FIRST ROW DOES NOT CONTAIN VARIABLE HEADERS
#	IT WOULD TREAT THE HEADERS AS A FIRST ROW OF ACTUAL DATA (AND WOULD
#	COME UP WITH ARBITRARY NAMES FOR OUR VARIABLES)

read.delim(file = "RExam.dat", header = F, na.strings = "NA")

# MANY ARGUMENTS IN EVERY FUNCTION HAVE THEIR DEFAULT VALUES, IF WE
# ARE SATISFIED WITH THE DEFAULTS, WE DO NOT NEED TO SPECIFY THE
# ARGUMENTS FURTHER:

read.delim(file = "RExam.dat")

# IF WE SPECIFY ARGUMENTS IN CORRECT ORDER, WE DONT EVEN NEED TO 
# USE ARGUMENT NAMES:

read.delim("RExam.dat", F)

# R KNOWS, THAT THE FIRST ARGUMENT IS SUPPOSED TO BE THE NAME OF THE
# DATAFILE, SO WE DONT NEED TO SPECIFY IT FURTHER: "file ="
#HOWEVER, IF WE MESS UP THE ORDER, THE FUNCTION WILL NOT WORK AS INTENDED:

read.delim(F, "RExam.dat")


#WE CAN USE VERY SIMILAR FUNCTIONS TO LOAD DATA IN .csv FORMAT

data2 <- read.csv("data.csv")

#IF WE WANTED TO LOAD THE DATAFILE IN .sav (SPSS FORMAT), WE CAN USE
# FUNCTION read.spss() OF THE PACKAGE foreign()

library(foreign)
read.spss("Lecturer Data.sav", to.data.frame=T)

#IF WE ARE LOADING THE DATAFILE IN .sav FORMAT, WE NEED TO SPECIFY TO R
# THAT IT SHOULD READ IT AS A DATA.FRAME, OTHERWISE IT WILL ONLY LOAD
# THE FILE AS A LIST OF INDIVIDUAL VARIABLES:

read.spss("Lecturer Data.sav")

#IF WE WANT TO NOT ONLY LOOK AT THE DATA ONCE, BUT WORK WITH THEM FURTHER,
# WE NEED TO CREATE AN OBJECT THAT CONTAINS THE DATAFILE
#	SO WE WILL USE THE FUNCTION WHICH LOADS THE DATA FROM FILES TO CREATE
#	AN OBJECT data

data <- read.delim("RExam.dat")
data




# WORKING WITH THE DATA - EXPLORING DATA, DIFFERENT DATA FROMATS

data2

# OBJECT OF THIS TYPE IS CALLED A DATA.FRAME
# IT CONTAINS SEVERAL VARIABLES (name, job, friends, ...) WHICH MAY
# 	CONTAIN NUMBERS OR TEXT, AND IT REPRESENTS DATA OF 10 PARTICIPANTS
#	IT IS AN OBJECT WHICH CONSISTS OF SEVERAL SIMPLER OBJECTS (VARIABLES)

#IF MOST CASES WHEN YOU WANT TO WORK STATISTICALLY WITH THE DATA, YOU NEED
#	TO HAVE THEM IN THIS FORMAT (SO-CALLED WIDE FORMAT) WHERE EVERY ROW
#	REPRESENTS DATA FROM ONE PARTICIPANTS, THERE ARE, HOWEVER, OTHER FORMATS
#	WHICH ARE SOMETIMES USED FOR SPECIFIC STATISTICAL PROCEDURES (MORE ON THEM LATER...)


data2$name
data2$job
data2$friends


# IF WE WORK WITH A DATA.FRAME WE CAN USE A DOLLAR SIGN TO ACCESS INDIVIDUAL
# VARIABLES (OBJECTS WITHIN A DATA.FRAME) - WE FIRST SPECIFY THE NAME OF THE
# DATA.FRAME, USE A DOLLAR SIGN AND SECIFY THE NAME OF INDIVIDUAL VARIABLE



# NOW THAT YOU KNOW WHAT DATA IN R LOOK LIKE, WE CAN TRY TO CREATE THEM
# MANUALLY

#WORKING WITH DATA - CREATING OUR OWN DATA
# DATA.FRAME IS ESSENTIALLY AN OBJECT WHICH CONTAINS SEVERAL OTHER OBJECTS 
# THAT CONSIST OF NUMBERS AND TEXT

#CREATING NUMERICAL VARIABLES - VARIABLE age CONTAINING AGES OF 5 PARTICIPANTS

	#FUNCTION c() - COMBINE SEVERAL ARGUMENTS (CREATING A LIST)

age <- c(21, 45, 78, 63, 33)
age



#CREATING A VERBAL VARIABLE

name <- c("Michael", "Catherine", "Anne", "Josh")
name

	#IF WE ARE SPECIFIING VERBAL CONTENT, WE NEED TO PUT IT IN 
	#QUOTATION MARKS (SO THAT R KNOWS IT IS A TEXT), NUMBERS AND
	#OBJECTS HOWEVER, ARE USED WITHOUT QUOTATION MARKS

"2" + "2"
	
	#IF WE PUT NUMBERS IN QUOTATION MARKS, R TREATS THEM AS A TEXT
	#AND CANNOT CONDUCT MATHEMATICAL OPERATIONS ON THEM

name <- c(name, "Sophie")
name

	#AS name IS WITHOUT QUOTATION MARKS, R KNOWS IT IS AN OBJECT



#CREATING SIMPLE DATA.FRAME - A data.frame() FUNCTION


research <- data.frame (id = name, ages = age)
research

	#AS YOU ALREADY SAW, WE CAN WIRTE UP SEVERAL FUNCTION INTO ONE
	#SUCH AS WITH setwd(choose.dir())
	#THE MORE YOU ARE GOING TO WORK WITH R, THE MORE YOU WILL GET USED
	#TO COMBINING SEVERAL COMMANDS WITH MORE FUNCTIONS:


research <- data.frame(id = c("Michael", "Catherine", "Anne", "Josh", "Sophie"), 
				ages = c(21, 45, 78, 63, 33))

#THIS WAY WE WOULD CREATE THE SAME DATA AS BEFORE, BUT WE WOULD DO THIS IN ONE COMMAND

#AS WE ALREADY KNOW, WE CAN WORK WITH INDIVIDUAL VARIABLES WITHIN A DATA.FRAME BY
# USING A DOLLAR SIGN

research$ages



#WORKING WITH DATA - SELECTING A PART OF A DATA.FRAME
	#R WORK WITH DATA.FRAME AS WITH A TABLE OF VALUES
	#WE CAN SELECT A SPECIFIC VALUE BY SPECIFIING
	#ITS POSITION IN A TABLE [row, column]

research[3,2]

	#SHOWS A VALUE IN THIRD ROW AND SECOND COLUMN

research[1,]

	#SHOWS ALL VALUES IN THE FIRST ROW (FIRST PARTICIPANT)

research[,2]

	#SHOWS ALL VALUES IN THE SECOND COLUMN (SECOND VARIABLE)

#IF WE ARE ONLY INTERESTED IN SEVERAL VARIABLES, WE COULD USE

research[, c("id", "ages")]

#IF WE ARE ONLY INTERESTED IN SEVERAL PARTICIPANTS, WE USE (1:3 = 1,2,3)

research[c(1:3),]





#SAVING THE DATA (THEY WILL BE SAVED IN THE WORKING DIRECTORY)

write.csv(research, "research.csv")
write.table(research, "research.txt", sep = "\t")




#CREATING FACTOR VARIABLES

#LETS SAY 5 PARTICIPANTS IN OUR EXPERIMENT WERE ASSIGNED INTO
# EXPERIMENTAL AND CONTROL GROUP

research$group <- c(0,0,1,1,1)

	#IN SIMILAR SITUATIONS WE CAN USE FUNCTION rep() IN WHICH
	#WE NEED TO SPECIFY THAT IT SHOULD REPEAT, AND HOW MANY
	#TIMES IT SHOULD REPEAT IT:
	
rep(1,5)

	#SO FOR RECREATING THE ABOVEMENTIONED COMMAND WE COULD WRITE:

research$group <- c(rep(0, 2), rep(1, 3))

	#NOW WE CAN USE FUNCTION factor() WHICH TELLS R THAT SELECTED
	#VARIABLE IS A FACTOR VARIABLE (CATEGORICAL VARIABLE)
	#GENERAL STRUCTURE OF A FUNCTION IS:
	#
	#factor(variable, levels = XY, labels = ZW)
	#
	#variable = AN OBJECT WHICH IS USED TO CREATE A FACTOR
	#levels = HOW MANY LEVELS DOES THE FACTOR HAVE
	#labels = HOW ARE LEVELS LABELED
	

research$group <- factor(research$group, levels = c(0,1), 
			labels = c("control", "experimental"))






################## DESCRIPTIVE STATISTICS ######################

data<-read.csv("data.csv")

#BASIC INFORMATION ABOUT AN OBJECT

head()

	#FUNCTION head() SHOWS US ONLY FIRST FIVE ROWS OF A DATAFRAME, WHICH
	#	IS VERY USEFUL WHEN WE ARE WORKING WITH LARGE DATASETS (MOSTLY
	#	IT IS INCONVENIENT TO PRINT THE WHOLE DATASET, FIRST FIVE ROWS
	#	ARE SUFFICIENT TO GET A SENSE OF WHAT THE DATAFRAME CONSISTS OF)

str()

	#FUNCTION str() PROVIDES US WITH A DETAILED INFO OF A DATAFRAME, SPECIFICALLY,
	#	WHAT VARIABLES DOES THE DATAFRAME CONSIST OF, HOW MANY PARTICIPANTS ARE
	#	THERE, WHAT TYPE OF VARIABLES ARE USED, AND WHAT ARE THERE MOST OFTEN VALUES

str(data)

	#IN THIS CASE R MANAGED TO UNDERSTAND THAT THE GROUP VARIABLE IS ACTUALLY A FACTOR,
	#	HOWEVER, THIS IS NOT ALWAYS THE CASE. IF WE NEEDED TO SPECIFY IT MANUALLY, WE
	#	COULD USE:

data$group <- factor(data$group, levels = c("kontrolna","experimentalna"), 
			labels = c("control", "experimental"))


#BASIC DESCRIPTIVE STATISTICS

mean(data$income)

median(data$income)

#FUNCTION MODE DOES NOT PRODUCE MODE (IT HAS A DIFFERENT PURPOSE)
mode(data$income)


#WE CAN USE 

table(data$neurotic)

#TO PRODUCE THE FREQUENCY TABLE, THEN SORT IT BY:

sort(table(data$neurotic))

#WE CAN SPECIFY DECREASING ORDER OF SORTING AND PRINT A FIRST VALUE:

sort(table(data$neurotic), decreasing = T)[1]

sd(data$income)
var(data$income)

	#WE CAN CHECK THESE VALUES:

		sum(data$income)/length(data$income)
		mean(data$income)
		mean(data$income)==sum(data$income)/length(data$income)


		sqrt(var(data$income))
		sd(data$income)
		sd(data$income)==sqrt(var(data$income))


#OTHER FUNCTIONS FOR DESCRIBING VARIABLES:

range(data$income)
sum(data$income)
min(data$income)
max(data$income)
IQR(data$income)


quantile(data$income, probs = seq(0, 1, 0.25))

iqr<-quantile(data$income, probs = seq(0, 1, 0.25))

seq(0,1, 0.25)

#PRODUCES SEQUENCE FROM 0 TO 1 WITH .25 INTERVALS

iqr[2]
iqr[4]



####FUNCTION by()
	#GENERAL STRUCTURE:
	#
	#	by(data, indices, function)
	#
	#	data = object we are going to be working with
	#	indices = variable which should be used for splitting the analysis
	#	function = function that we want to execute

#IF WE WANTED TO COMPARE MEANS IN CONTROL AND EXPERIMENTAL GROUP
	#IN THE VARIABLE data$income, WE USE:

by(data$income, data$group, mean)

#IF WE WANTED TO GET A STANDARD DEVIATION IN NEUROTICISM SEPARATELY FOR
	#MANAGERS AND STUDENTS, WE USE:

by(data$neurotic, data$job, sd)





#BEWARE OF THE MISSING VALUES IN DATA - GENERIC ARGUMENT na.rm = T

#IF WE ENTERED ONE MISSING VALUE TO OUR DATA:

data$income[5] = NA
data

#WE WONT BE ABLE TO DO ANY OF THE ABOVEMENTIONED FUNCTIONS:

mean(data$income)
sum(data$income)
min(data$income)
sd(data$income)

#IF WE ARE WORKING WITH THE DATA WHERE THERE ARE MISSING VALUES, WE
# 	NEED TO SPECIFY, WHAT R IS SUPPOSED TO DO WITH THOSE,
#	ARGUMENT na.rm = T WILL TELL R TO IGNORE MISSING VALUES IN
#	ANY COMPUTATION

mean(data$income, na.rm=T)
sum(data$income, na.rm=T)
min(data$income, na.rm=T)
sd(data$income, na.rm=T)

by(data$income, data$group, mean)

by(data$income, data$group, mean, na.rm = T)


#BUT LETS BRING BACK THE ORIGINAL VALUE TO OUR DATA SO WE DONT HAVE TO
#SPECIFY ADDITIONAL ARGUMENT IN EVERY FUNCTION WE DO FROM NOW ON:

data$income[5] = 50000







######## FURTHER TOPICS IN DESCRIPTIVE STATISTICS ##########
####OVERALL DATA EXPLORATION

install.packages("psych")
install.packages("pastecs")

library(psych)


#THERE ARE SEVERAL FUNCTIONS WHICH CAN BE USED FOR OVERALL DATA DESCRIPTION
#   FIRST ONE IS FUNCTION describe() OF PACKAGE psych

describe(data$income)
describe(data)
describe(data, IQR = T)
describe(data, IQR = T, trim=.3)
describe(data[,c(3,5)])

#R WILL TRY TO USE DESCRIPTIVE STATISTICS EVEN ON VARIABLES, THAT ARE
#CATEGORICAL - YOU WILL HAVE TO REMEMBER TO IGNORE THIS VALUES

by(data, data$group, describe)


#SECOND FUNCTION FOR OVERALL DATA DESCRIPTION IS stat.desc() OF PACKAGE pastecs

library(pastecs)

stat.desc(data$income)
stat.desc(data$group)

#IS MORE INTELLIGENT - WONT CALCULATE DESCRIPTIVE STATISTICS FOR
#FACTOR VARIABLES AND STRING VARIABLES


#IF WE WANT ALSO INFORMATION ABOUT SKEWNESS AND KURTOSIS AND NORMALITY,
	#WE NEED TO USE ARGUMENT norm = T

stat.desc(data$income, norm = T)

#MORE ON NORMALITY TESTS ON NEXT LECTURE

#HOWEVER, OUTPUT OF stat.desc() FUNCTION IS VERY HARD TO READ (INSTEAD
#OF DECIMAL PLACES IT USES AN EXPONENTIATION FORMAT
#WE CAN USE FUNCTION round() TO GET RESULTS IN MORE DECIPHERABLE FORM:

round(1.65465, 2)

#FUNCTION ROUNDS THE NUMBER 1.65465 TO THE CLOSEST TWO DECIMAL PLACES
#BUT WE CAN ALSO USE IT FOR THE WHOLE OUTPUT OF stat.desc() FUNCTION:

round(stat.desc(data$income), 2)
round(stat.desc(data$income, norm = T), 2)

#IF WE WANT TO USE stat.desc() FUNCTION TO DESCRIBE MORE VARIABLES AT
#ONCE, WE CAN SELECT VARIABLES FROM THE DATA.FRAME AND INCLUDE THEM
#ALL IN THE FUNCTION AT THE SAME TIME:


data[,c(3,5)]

	#THIS IS A PART OF DATAFRAME WHICH CONTAINS ONLY 3RD AND 5TH
	#VARIABLE - (FRIENDS AND INCOME)

stat.desc(data[,c(3,5)], norm = T)

	#OR WE CAN INCLUDE THE WHOLE DATA.SET

stat.desc(data, norm = T)

	#HOWEVER, IF WE ENTER THE WHOLE DATAFRAME INTO THE FUNCTION, ROUND
	#WILL NOT WORK, BECAUSE IN DATAFRAME THERE ARE CATEGORICAL VARIABLES

round(stat.desc(data, norm = T),2)

	#SO IF WE WANT TO DO THIS, WE NEED TO SELECT ALL THE VARIABLES
	#AND PUT THEM INTO FUNCTION MANUALLY

round(stat.desc(data[,c(3,4,5,6)], norm = T), 2)


################## BASIC OF VISUALIZING DATA ######################

#FREQUENCY TABLE (FIRST ROW ARE VALUES, SECOND ROW THEIR FREQUENCIES)

table(data$neurotic)


#WE CAN ALSO USE GENERIC table() FUNCTION TO GET FREQUENCY TABLE DEPENDENT
#ON AN EXPERIMENTAL CONDITION

table(data$group,data$neurotic)


#WE CAN USE VERY BASIC plot() FUNCTION OF R CORE TO CREATE
#	BASIC GRAPHS THAT WILL AT LEAST SUFFICE FOR THE EXPLORATION OF DATA
#	HOWEVER, MORE COMPLEX (AND PRETTIER) GRAPHS ARE QUITE HARD TO CREATE
#	AS THEY REQUIRE MORE ADVANCED FUNCTIONS


#SIMPLE HISTOGRAM

hist(data$neurotic)

#IF WE WANT OUR HISTOGRAM TO CONTAIN MORE COLUMNS (SO IT DOES NOT COMBINE
#SEVERAL VALUES INTO ONE BIN), WE NEED TO SPECIFY:

hist(data$neurotic, breaks=seq(0,30,1))

#REMEMBER THAT THIS WILL CREATE A SEQUENCE FROM 0 TO 30 WITH INTERVAL OF 1

hist(data$neurotic, breaks=seq(0,30,5))

#WE CAN ALSO USE SEVERAL ARGUMENTS TO VARY THE AESTHETICS OF A GRAPH

hist(data$neurotic, main = "Histogram of neuroticism", ylab = "Frequency", xlab = "neuroticism values")

hist(data$neurotic, border = "#123456", col = c("blue", "green", "red", "brown", "black"))

hist(data$neurotic, ylim=c(0,10))


###WE CAN GET A SIMPLE BOXPLOT, IF WE USE plot() FUNCTION ON A CONTINUOUS
#VARIABLE ALONG WITH SOME FACTOR VARIABLE:

plot(data$job, data$neurotic)
boxplot(data$neurotic ~ data$job)


#BOXPLOT FUNCTION CAN BE USED EVEN IF WE ARE COMPARING MORE THAN TWO GROUPS:

data$nationality<-c(rep("slovak", 3),rep("czech", 3), rep("german", 4))
data

boxplot(data$nationality, data$neurotic)

#IT RESULTS IN ERROR BECAUSE WE HAVE NOT SPECIFIED THAT NATIONALITY IS A FACTOR:
# WE NEED TO USE FUNCTION as.factor() WHICH TELLS R TO TREAT A VARIABLE AS A FACTOR:

plot(as.factor(data$nationality), data$neurotic)


####SIMPLE SCATTERPLOT IS CREATED IF WE USE plot() FUNCTION ON TWO CONTINUOUS VARIABLES

plot(data$income, data$neurotic)

#WE CAN ADD A REGRESSION LINE TO THE PLOT BY CALCULATING SIMPLE
#LINEAR MODEL (FUNCTION lm() WHICH CAN BE USED TO CALCULATE REGRESSION
#MODELS (MAYBE ON NEXT LECTURES)

abline(lm(data$neurotic~data$income),col="red")


#ABOVE ARE GRAPHS CREATED BY GENERIC plot() FUNCTION
#THERE ARE SEVERAL MORE COMPLICATED FUNCTIONS (EVEN PACKAGES)
#FOR VISUALIZING DATA, MY FAVORITE IS ggplot2
#HOWEVER, LEARNING HOW TO MAKE GRAPHS IN GGPLOT2 IS QUITE
#COMPLICATED, BECAUSE YOU HAVE TO CREATE GRAPHS LAYER
#AFTER LAYER FORM SCRATCH:

setwd("C://Users/Kubo/Documents/Work/Empirical Research Methodology/Applied statistics in R")
data.bar<-read.delim("ChickFlick.dat", header = TRUE)
library(ggplot2)
barchart<-ggplot(data.bar, aes(film, arousal, fill = film))
barchart + stat_summary(fun.y = mean, geom = "bar",
colour = "Black") + stat_summary(fun.data = mean_cl_normal, geom = "errorbar"
, width = 0.2) + facet_wrap(~gender) + theme(legend.position = "none")

#IF YOU WANT TO LEARN HOW TO DO PLOTS IN GGPLOT2, CHECK ANDY FIELDS
#BOOK, OR ONLINE DOCUMENTATION FOR GGPLOT2 PACKAGE

